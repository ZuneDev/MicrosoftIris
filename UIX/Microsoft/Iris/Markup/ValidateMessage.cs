// Decompiled with JetBrains decompiler
// Type: Microsoft.Iris.Markup.ValidateMessage
// Assembly: UIX, Version=4.8.0.0, Culture=neutral, PublicKeyToken=ddd0da4d3e678217
// MVID: A56C6C9D-B7F6-46A9-8BDE-B3D9B8D60B11
// Assembly location: C:\Program Files\Zune\UIX.dll

namespace Microsoft.Iris.Markup
{
    internal static class ValidateMessage
    {
        public const string AliasCycleDetected = "Alias cycle detected: {0} {1}";
        public const string AliasTypeRequired = "Alias Type property must be provided";
        public const string AliasTargetTypeNotFound = "Target type for alias '{0}' could not be found";
        public const string AssemblyLoadFailure = "Failure loading assembly";
        public const string AssemblyLoadFailureSpecific = "Failure loading assembly: '{0}'";
        public const string AssemblyInvalidReferenceNoWhack = "Invalid assembly reference '{0}'.  URI must contain a forward slash after the assembly name";
        public const string AttributeMustBeBoolean = "Property '{0}' must be Boolean 'true' or 'false'";
        public const string BaseKeywordCanOnlyBeUsedInOverrideMethod = "'base' keyword can only be used in an override method";
        public const string BaseKeywordCanOnlyCallMethod = "'base' keyword can only be used to call the base virtual method inside an override";
        public const string BaseTypeCannotBeShared = "Base type cannot be a shared Class";
        public const string BaseTypeMustBeClass = "Base type must be a markup-defined Class type";
        public const string BaseTypeMustBeMarkupDefined = "Base type must be a markup-defined type";
        public const string BaseTypeMustBeTypeIdentifier = "Base must be a type identifier (prefix:Type)";
        public const string BaseTypeMustBeUI = "Base type must be a markup-defined UI type";
        public const string BreakMustBeInLoop = "No enclosing loop out of which to break or continue";
        public const string CodeBlockRequiresReturn = "Code block must end with a return of type '{0}'";
        public const string CodeReturnValueTypeMismatch = "Return values are not supported for this code block (currently returning '{0}')";
        public const string CodeMustReturnSomething = "Code block must have at least one return statement of type '{0}'";
        public const string ConstructorNotFoundOnType = "A matching constructor could not be found on '{0}'";
        public const string ContentOverrideTypeMismatch = "Content Name '{0}' exists in base class '{1}' with type '{2}' and type override '{3}' does not match";
        public const string ContentNameNotOverridden = "Missing content name declaration: base type '{0}' has declared content name '{1}' of type '{2}'";
        public const string DataIsMalformedPerEncoding = "Malformed input file.  The file contains data which is not valid in the {0} encoding";
        public const string DeclaredTriggersCannotBeBaseOnScopedLocals = "Expression cannot be declared as a trigger since '{0}' is a temporary (scoped) variable";
        public const string DeclaredTriggersMustHaveOuterNotifyingMember = "Expression cannot be declared as a trigger since it does not have an outermost property or event that fires notifications";
        public const string DeclaredTriggerOnlySupportedInScripts = "Expressions can only be used as triggers if they exist within Script blocks";
        public const string DefaultConstructorNotFound = "Type '{0}' may only be created via indirection (i.e. <{0} {0}=\"...\"/>)";
        public const string DictionaryPropertyValuesMustBeNamed = "Dictionary property '{0}' requires all values be named";
        public const string DuplicatePropertyFound = "Property '{0}' was specified more than once";
        public const string DuplicateTypeFound = "Type '{0}' was specified more than once";
        public const string ExpressionCannotBeLValue = "Expression cannot be used as the target an assignment (related symbol: '{0}')";
        public const string ExpressionMemberAccessGetOnly = "Expression access to '{0}' only supports read operations";
        public const string ExpressionMemberAccessSetOnly = "Expression access to '{0}' only supports write operations";
        public const string ExpressionMemberAccessUnavailable = "Expression access to '{0}' is not available";
        public const string ExpressionOperationTypeMismatch = "Operator '{0}' cannot be applied to operands of dissimilar types '{1}' and '{2}'";
        public const string ExpressionOperationUnsupported = "Operator '{0}' cannot be applied to operand of type '{1}'";
        public const string ExpressionConditionalTypeMismatch = "Both expressions for the {0} operator must match: '{1}' and '{2}' are not compatible";
        public const string FoundTypeEnumeratorIsNotCorrectType = "While searching for an enumerator, a 'GetEnumerator' method was found on '{0}', but, it is not of type 'Enumerator' (it is '{1}')";
        public const string InvalidSymbolName = "Invalid name \"{0}\".  Valid names must begin with either an alphabetic character or an underscore and can otherwise contain only alphabetic, numeric, or underscore characters";
        public const string InvalidTypeCast = "Cannot cast '{0}' to '{1}'";
        public const string InvalidValue = "Specified value '{0}' is not valid";
        public const string InvalidEscapeSequence = "Invalid escape sequence '{0}' in string literal";
        public const string LexerSyntaxErrorFormat = "Syntax Error: Unexpected character encountered: '{0}'";
        public const string MalformedAssemblyName = "Malformed assembly name '{0}'";
        public const string MarkupTypeCyclicReference = "Circular base class dependency involving '{0}' and '{1}'";
        public const string MemberNotFoundOnType = "Unable to find a Property, Event, or Method called \"{0}\" on '{1}'";
        public const string MethodAlreadyDefined = "Method '{0}' was already defined in this class with the same signature";
        public const string MethodDefinedInBaseNotVirtual = "Method '{0}' was already defined in '{1}' with the same signature and was not declared virtual";
        public const string MethodNoMethodToOverride = "Method '{0}' declared override, but no base method found to override";
        public const string MethodMustUseOverride = "Method '{0}' is virtual in '{1}', must use 'override' to override";
        public const string MethodReturnTypeMustBeTheSame = "Method '{0}' overrides base method from '{1}', but return types do not match: '{2}' on override, '{3}' on base.";
        public const string MethodSpecifierConflictVirtualOverride = "Only one of 'virtual' and 'override' is allowed";
        public const string MethodSpecifierDuplicated = "Duplicate modifier '{0}'";
        public const string MethodsAllowedOnClassOnly = "Methods allowed only on <Class>, <UI> and <Effect>";
        public const string MethodsSpecifiedMoreThanOnce = "Methods may only be specified once";
        public const string MultipleValuePropertyMustHaveObjectTagValues = "Collection property '{0}' may only have multiple values specified in expanded form";
        public const string NameAlreadyInUse = "Name \"{0}\" is already in use (type '{1}') located in '{2}'";
        public const string NameIsReserved = "Name \"{0}\" is reserved and cannot be used.";
        public const string NameOverrideDisallowedCrossOrigin = "Name \"{0}\" (located in {1}) cannot override the same name within base class '{2}' (located in {3}) since overrides cannot cross section types";
        public const string NameOverrideDisallowedForOrigin = "Name \"{0}\" (also defined in base class '{1}') cannot be overridden (tried to override {2}, but can only override Properties and Content)";
        public const string NamePropertyRequired = "'Name' property is required and must be provided";
        public const string NameUsageOutOfScope = "Name \"{0}\" may not be used in this context since the tag is not within a Properties, Locals, Input, or Content block";
        public const string NamedContentAttributeMisconfiguration = "Named Content must have a single 'Name' attribute";
        public const string NegativeValuesUnsupported = "Expecting a non-negative value, but got {0}";
        public const string NestedDeclaredTriggersNotAllowed = "Declared triggers may not exist within other declared triggers";
        public const string NullConstantNotAllowedInNullCoalescing = "Null constant may not be used as the condition for ?? operator";
        public const string OutOfRangeMin = "Expecting a value no smaller than {0}, but got {1}";
        public const string OutOfRangeMinMax = "Expecting a value between {0} and {1}, but got {2}";
        public const string OutOfRangeMinMaxExclusive = "Expecting a value between {0} and {1} (exclusive), but got {2}";
        public const string ParameterizedConstructorNotFoundOnType = "A matching constructor could not be found on '{0}' that accepts parameters '{1}'";
        public const string ParameterizedMethodNotFoundOnType = "Unable to find a Method \"{0}\" that accepts parameters '{1}' on '{2}'";
        public const string ParserSyntaxErrorFormat = "Syntax Error: Unexpected character encountered: '{0}'";
        public const string PropertiesUnsupportedOnIndirectionContainers = "Property sets are not supported on type indirection tag. Property specified was '{0}'";
        public const string PropertyAttributesNotSupported = "Property attributes are not supported on property '{0}'";
        public const string PropertyDoesNotSupportMultiValue = "Property '{0}' does not support multiple values (property type is '{1}')";
        public const string PropertyDoesNotSupportReadingForCollectionAdd = "Property '{0}' must support reading to retrieve its collection for multiple value adds";
        public const string PropertyDoesNotSupportSetting = "Property '{0}' does not support setting";
        public const string PropertyMultipleValueScriptBlocksUnsupported = "Property '{0}' does not support multi-value script blocks";
        public const string PropertyNotFoundOnType = "Property '{0}' does not exist on '{1}'";
        public const string PropertyOverrideFound = "Property '{0}' was specified as Override='false' but a base property was found";
        public const string PropertyOverrideNotFound = "Property '{0}' was specified as Override='true' but no property was found to override";
        public const string PropertyOverrideTypeMismatch = "Property '{0}' exists in base class '{1}' with type '{2}' and type override '{3}' does not match";
        public const string PropertyRequiresValue = "Property '{0}' requires a value to be provided";
        public const string PropertyValueCannotHaveMixedTagCodeValues = "Property '{0}' cannot contain both object-tag and script block values";
        public const string PropertyValueMustBeExpanded = "Property '{0}' values must be in expanded form";
        public const string PropertyValueNotInline = "Property '{0}' does not support expanded value syntax";
        public const string PropertyValueTypeMismatch = "Property '{0}' expects a value of type '{1}' but got a value of type '{2}'";
        public const string RequiredPropertyNotSpecified = "Property '{0}' must be specified for '{1}' to function";
        public const string RequiredPropertyNotProvided = "Property '{0}' must be specified";
        public const string RequiredProperyDeclarationOnlyForMarkupTypes = "'$Required' can't be used in this context. It may only be used for declaring required properties on Classes and UIs";
        public const string ReturnTypeCannotBeInferred = "Return type cannot be determined due to inconsistant return type statements (mismatched types are: '{0}' and '{1}')";
        public const string RightAngleExpected = "Expecting a value of 0, 90, 180, or 270, but got {0}";
        public const string RootElementMustBeClass = "Unexpected root element '{0}', must be <Class>, <UI> or <Alias>";
        public const string ScriptAttributeNotFound = "Script attribute '{0}' is unknown";
        public const string ScriptAttributeParameterCountInvalid = "Script attribute '{0}' invalid number of parameters (expecting: {1})";
        public const string ScriptAttributeParameterMustBeBoolean = "Script attribute parameter must be Boolean 'true' or 'false'";
        public const string ScriptInvalidStartCharacter = "Invalid starting script character '{0}'";
        public const string StringConversionFailed = "Unable to convert \"{0}\" to type '{1}'";
        public const string StringConversionFailedOuter = "Problem converting '{0}' ({1})";
        public const string StringConverterUnavailable = "String conversion is not available for '{0}'";
        public const string StringLengthInvalid = "\"{0}\" cannot be longer than {1} characters";
        public const string SymbolNotFound = "Unable to locate symbol \"{0}\" within Properties, Locals, Input, or Content";
        public const string SyntaxErrorUnexpectedEOF = "Unexpected end of script (script beginning at line {0}, column {1})";
        public const string SyntaxErrorTypeCastExpectingSymbol = "Type cast was expecting symbol, found '{0}'";
        public const string TagMismatch = "Mismatched tags found: <{0}> ... </{1}>";
        public const string TechniqueElementCannotBeNamed = "Element '{0}' has no properties that can be changed dynamically and therefore cannot be named";
        public const string TechniqueElementPropertyNotDynamic = "Element '{0}' property '{1}' is being assigned a value which requires it to be set dynamically, but the property cannot be changed dynamically";
        public const string TechniqueOverrideNotAllowed = "Overriding Techniques property is not allowed; base class has already defined techniques";
        public const string TypeConstraintDefinitionMismatch = "Type '{0}' does not match specified constraint '{1}'";
        public const string TypeConstraintPropertyValueNotConstant = "Type parameter property '{0}' must be supplied a type constant (by name, or via 'typeof')";
        public const string TypeConstraintTypeMismatch = "Type parameter property '{0}' is of type '{1}' which is not compatible with the base type constraint '{2}'";
        public const string TypeConverterUnavailable = "Type conversion is not available for '{0}'";
        public const string TypeIsNotEnumerable = "Type '{0}' is not enumerable";
        public const string TypeMismatch = "'{0}' cannot be used in this context (expecting types compatible with '{1}')";
        public const string TypeMismatchAssignment = "Invalid assignment: Type '{0}' cannot be assigned to type '{1}'";
        public const string TypeMustBeNullAssignable = "The {0} operator must be used with a reference type ('{1}' is not null assignable)";
        public const string TypeNotFound = "Type '{0}' was not found within '{1}'";
        public const string TypeNotPublic = "Type '{0}' is not public in '{1}'";
        public const string UICannotBeShared = "UI cannot be marked as shared";
        public const string UIXRootTagScopeNotFound = "Unknown markup format. Expecting <UIX> ... </UIX> root markup tags";
        public const string ValueMustBeCodeBlock = "Expecting <Script> block";
        public const string VersionNumberUnsupported = "Unsupported version of markup: '{0}'";
        public const string XmlnsLoadFailure = "Unable to load '{0}' (xmlns prefix '{1}')";
        public const string XmlnsPrefixUnknown = "Xmlns prefix '{0}' was not found";
        public const string XmlAttributeWithPrefixDisallowed = "Property or Object tag may not have prefixed attributes: '{0}'";
        public const string XmlObjectTagTextDisallowed = "Object tag may not contain Text/CDATA: '{0}'";
        public const string XmlPropertyMultipleTextDisallowed = "Property tag may only contain one Text/CDATA, found more text: '{0}'";
        public const string XmlPropertyTextAndObjectAreExclusive = "Property tag already has objects, may not also add Text/CDATA: '{0}'";
        public const string XmlPropertyTagWithPrefixDisallowed = "Property tag may not be prefixed: '{0}'";
        public const string XmlRootTagUnexpectedAttribute = "Unexpected attribute '{0}' on root tag";
        public const string XmlScriptCannotHaveAttributes = "Script tag may not have XML attributes";
        public const string XmlScriptCannotHaveXmlComments = "Script tag may not contain XML comments, found: '{0}'";
        public const string XmlScriptCannotHaveElements = "Script tag may not contain XML elements, found: '{0}'";
        public const string XmlScriptMultipleTextDisallowed = "Script tag may only contain one Text/CDATA, found more text: '{0}'";
        public const string XmlTextNotAllowedUnderRoot = "Text/CDATA is not allowed under root tag ('{0}')";
        public const string DataMappingDefaultValueTypeNotBinaryEncodable = "DefaultValue can only be on types that support binary encoding; '{0}' does not";
        public const string DataMappingDuplicateDataMapping = "Data mapping already defined for type '{0}', provider '{1}'";
        public const string DataMappingDuplicatePropertyMapping = "Mapping for property '{0}' was already specified";
        public const string DataMappingTypeExpressionNotValid = "Invalid expression for '{0}', expecting plain type identifier";
        public const string DataMappingInvalidAttributeValue = "Invalid value '{0}' for attribute '{1}'";
        public const string DataMappingInvalidProviderName = "Could not find provider '{0}'; verify that it has been registered";
        public const string DataMappingInvalidTargetType = "TargetType for DataMapping must be a markup-defined DataType, {0} is not valid";
        public const string DataMappingInlineMappingNeedsProvider = "Inline mappings are allowed only on provider-specific types.  Must specify 'Provider' attribute on '{0}'";
        public const string DataMappingInvalidPropertyNameForMapping = "Could not find property '{0}' on type '{1}' for data mapping with provider '{2}'";
    }
}
